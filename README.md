# 哈夫曼编码(Huffman coding)介绍

## 什么是哈夫曼编码

一种无损编码文本的方法, 能起到压缩文件体积的效果

## 定长与变长编码

### 什么是定长编码, 什么是变长编码

ascii编码是经典的定长编码, 使用8bit来表示一个字符

比如 a 用 0110 0001 表示, A 用 0100 0001, 可表示的字符数量为 2^8(128)个

变长编码是用不同长度的符号来表示一组符号的方式

比如 a 可以用 0 表示, A 可以用 00 表示

### 为什么我们要关心变长, 定长编码

显而易见的是, 变长编码在很多情况下会比定长编码**节约空间**

用 8bit 来表示一个字母 a 显然不如用 1bit 的 0 来表示 a 有效率(保存同等信息时, 占用更少空间)

## 无歧义的前缀

### 变长编码可能会有二义性

前面的例子里, 变长编码的 a 和 A 分别用 0 和 00 表示, 当我们有一串文本 aA 需要保存时, 可以在文件里写入 000

当我们需要还原保存的文本时, 一个显而易见的问题来了, 000 如何解析

我们可以把它解析为 aA, aaa, Aa 三种文本, 哪个才是原来保存的文本?

这带来了二义性

*注: 定长编码没有二义性的问题*

### 二义性怎么产生的

这个二义性的是 a (0) 可以作为 A(00) 的前缀导致的

解析时在读取一个 0 获得 a 后是否应该继续解析?

### 怎么解决二义性

任意字符的编码不可以作为别的字符的编码的前缀

a 可以用 0 表示, A 用 1 表示, 就消除了二义性

如果又增加一个字母b, 怎么办?

a 和 A 已经表示好了, 这两个字符作为一组, 可以用一个符号G0表示

这又回到两个字符的场景, 只要 G0 和 b 互不为对方的前缀即可, G0 用 0 表示, b 用 1 表示

展开 G0, 此时 a 用 00 , A 用 01 表示, 而 b 用 1 表示

aAb 这串字符可以存为 00011

## 压缩空间

一个现象: 一段文本里各个字母出现的频率是不同的

使用变长编码时, 可以将常见的字母用短一些的bit来表示, 少见的字母用长一点的bit表示 

## 哈夫曼编码的思想

上述就是哈夫曼编码的思想: 变长编码+高频字符用更短编码表示
